# DA_CJS_2018Fall

My final codes for every OJ test.  

Problems    
=
### [OJ-01] 圆与三角形  
#### [问题描述]  
给定二维平面上的一个圆和一个三角形，视两者为两个点集C和T。C和T均不包含图形的内部，仅包含图形的边界。判断集合C和T的交集是否非空。  
#### [输入格式]  
（第一行）正整数N，代表接下来有N组测试数据。  
（接下来的N行，每一行格式是：）r x0 y0 x1 y1 x2 y2 x3 y3 (解释：r为圆半径，(x0, y0)为圆心坐标，(x1,y1), (x2,y2), (x3,y3)为三角形3个顶点坐标)  
#### [数据范围]  
0<N<1,000,000;横、纵坐标属于区间[-1000, 1000]  
#### [输出格式]  
一共N行，每行输出数字0或1。若C和T交集非空，输出1；若C和T交集为空集，输出0.  
#### [输入样例]  
2  
1 0 0 5 5 6 6 7 4  
1 0 0 0 2 1 -1 2 1  
#### [输出样例]  
0  
1  
#### [提示]  
使用double数据类型可能更精确。  
使用<stdio.h>中的scanf，printf。它们比<iostream>中的cin, cout更快。  

### [OJ-02] 复杂链表  
#### [问题描述]  
一般链表中，每个结点会有一个Next指针指向下一个结点，而复杂链表则还有一个Random指针指向链表中的任意一个结点或者NULL。一个复杂链表结点的C++定义如下：
```c
struct ComplexNode  
{  
    int Value;  
    ComplexNode* Next;  
    ComplexNode* Random;  
};  
```
本次实验需要同学们实现复杂链表的构建、删除、插入、访问等操作，直面C语言中最困难的指针，希望同学们能够勇敢面对本次实验，相信大家经过本次实验后都能够熟练运用指针。  
#### [输入格式]  
题目的输入总共有5行，同学们需要构建一个包含N个结点的头结点不为空的复杂链表并完成相应操作，我们定义从头结点到尾结点依次为第0个结点到第N-1个结点。  
第一行包含4个整数。分别为N(链表结点个数), M(需要删除的结点个数), K(需要插入的结点个数)和目标结点的索引T(与输出有关，-1<T<N-M+K，T为整数)。  
第二行包含N个整数。依次为第0个结点到第N-1结点的值。  
第三行包含N个整数，依次为第0个结点到第N-1个结点的Random指针指向结点的索引。注意，若第X个整数为-1则说明第X-1个结点的Random指针指向NULL。  
第四行包含M个整数，依次为需要删除的结点在当前链表中的索引。注意，所有指向这些被删除结点的指针在结点删除后都应该指向NULL。每删除一个结点，则更新一次链表。  
第五行包含3K个整数，三个数为一组。每一组中的第一个整数为待插入结点的值，第二个整数为待插入结点在当前链表中插入后的索引，第三个整数为待插入结点在当前链表中插入后Random指向结点的索引（第三个整数为-1代表待插入结点的Random指针指向NULL）。每一个结点插入当前链表后，更新当前链表。  
#### [输入数据范围]  
每一个结点的值在区间[-20,20]内，0<N<20000,0<M<1000,0<K<1000  
#### [输出格式]  
 输出包含两行。  
 第一行：从目标结点T开始，通过Next指针访问链表，依次输出各结点的值，直到某一结点Next指针指向NULL，则输出-1结尾。  
 第二行：从目标结点T开始，通过Random指针访问链表，依次输出各结点的值，直到某一结点Random指针指向NULL，则输出-1结尾。  
#### [输入样例]  
5 2 2 0  
3 1 6 9 15  
2 4 -1 1 -1  
2 3  
1 0 2 10 3 -1  
#### [输出样例]  
1 3 1 10 9 -1  
1 1 -1  
#### [提示]  
使用<stdio.h>中的scanf，printf。它们比<iostream>中的cin, cout更快。  
题目的输入会保证对特定结点从Random指针进行访问时，不会出现“死锁”，即输出的序列长度一定是有限的。  
输入和输出每一行中的各元素均用空格隔开。  
每删除或插入一个新的结点后，链表都需要进行更新！  
M不大于N。  

### [OJ-03] 排队照相问题  
#### [问题描述]  
N（N为偶数）个高矮不同的人排成两排照相，要求每一排都是从矮到高排列，而第二排每个人比第一排对应的人要高，列出所有可能的结果。  
#### [输入格式]  
第一行正整数N（0<N<100）  
第二行第一个人的身高h1  
第三行第二个人的身高h2  
…  
第N+1行第N个人的身高hN  
#### [输出格式]  
1.每种情况占据一行；  
2.将第一排按照排队顺序输出身高，然后将第二排按照排队顺序输出身高；  
3.身高之间加空格（第二排最后一人后面为换行符，无空格），两排之间不加换行符（第一排最后一人与第二排第一人之间为空格）。  
4.最后统计所有情况数目并输出。  
#### [输入样例]  
4  
161  
162  
164  
163  
#### [输出样例]  
161 162 163 164  
161 163 162 164  
2  
或者下列输出也正确（即不同情况之间可交换顺序）：  
161 163 162 164  
161 162 163 164  
2  
#### [提示]
1.使用<stdio.h>中的scanf，printf。它们比<iostream>中的cin, cout更快。  
2.每种情况输出完成后要换行。  
3.在输出时，不同情况的输出先后顺序不影响答案的正确性。  
