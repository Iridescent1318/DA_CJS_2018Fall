# DA_CJS_2018Fall

My final codes for every OJ test.  

Problems    
=
### [OJ-01] 圆与三角形  
#### [限制条件]  
时间限制: 1000 ms 内存限制: 2048 KB  
#### [问题描述]  
给定二维平面上的一个圆和一个三角形，视两者为两个点集C和T。C和T均不包含图形的内部，仅包含图形的边界。判断集合C和T的交集是否非空。  
#### [输入格式]  
（第一行）正整数N，代表接下来有N组测试数据。  
（接下来的N行，每一行格式是：）r x0 y0 x1 y1 x2 y2 x3 y3 (解释：r为圆半径，(x0, y0)为圆心坐标，(x1,y1), (x2,y2), (x3,y3)为三角形3个顶点坐标)  
#### [数据范围]  
0<N<1,000,000;横、纵坐标属于区间[-1000, 1000]  
#### [输出格式]  
一共N行，每行输出数字0或1。若C和T交集非空，输出1；若C和T交集为空集，输出0.  
#### [输入样例]  
2  
1 0 0 5 5 6 6 7 4  
1 0 0 0 2 1 -1 2 1  
#### [输出样例]  
0  
1  
#### [提示]  
使用double数据类型可能更精确。  
使用<stdio.h>中的scanf，printf。它们比<iostream>中的cin, cout更快。  

### [OJ-02] 复杂链表  
#### [限制条件]  
时间限制: 2000 ms 内存限制: 2048 KB  
#### [问题描述]  
一般链表中，每个结点会有一个Next指针指向下一个结点，而复杂链表则还有一个Random指针指向链表中的任意一个结点或者NULL。一个复杂链表结点的C++定义如下：
```c
struct ComplexNode  
{  
    int Value;  
    ComplexNode* Next;  
    ComplexNode* Random;  
};  
```
本次实验需要同学们实现复杂链表的构建、删除、插入、访问等操作，直面C语言中最困难的指针，希望同学们能够勇敢面对本次实验，相信大家经过本次实验后都能够熟练运用指针。  
#### [输入格式]  
题目的输入总共有5行，同学们需要构建一个包含N个结点的头结点不为空的复杂链表并完成相应操作，我们定义从头结点到尾结点依次为第0个结点到第N-1个结点。  
第一行包含4个整数。分别为N(链表结点个数), M(需要删除的结点个数), K(需要插入的结点个数)和目标结点的索引T(与输出有关，-1<T<N-M+K，T为整数)。  
第二行包含N个整数。依次为第0个结点到第N-1结点的值。  
第三行包含N个整数，依次为第0个结点到第N-1个结点的Random指针指向结点的索引。注意，若第X个整数为-1则说明第X-1个结点的Random指针指向NULL。  
第四行包含M个整数，依次为需要删除的结点在当前链表中的索引。注意，所有指向这些被删除结点的指针在结点删除后都应该指向NULL。每删除一个结点，则更新一次链表。  
第五行包含3K个整数，三个数为一组。每一组中的第一个整数为待插入结点的值，第二个整数为待插入结点在当前链表中插入后的索引，第三个整数为待插入结点在当前链表中插入后Random指向结点的索引（第三个整数为-1代表待插入结点的Random指针指向NULL）。每一个结点插入当前链表后，更新当前链表。  
#### [输入数据范围]  
每一个结点的值在区间[-20,20]内，0<N<20000,0<M<1000,0<K<1000  
#### [输出格式]  
 输出包含两行。  
 第一行：从目标结点T开始，通过Next指针访问链表，依次输出各结点的值，直到某一结点Next指针指向NULL，则输出-1结尾。  
 第二行：从目标结点T开始，通过Random指针访问链表，依次输出各结点的值，直到某一结点Random指针指向NULL，则输出-1结尾。  
#### [输入样例]  
5 2 2 0  
3 1 6 9 15  
2 4 -1 1 -1  
2 3  
1 0 2 10 3 -1  
#### [输出样例]  
1 3 1 10 9 -1  
1 1 -1  
#### [提示]  
使用<stdio.h>中的scanf，printf。它们比<iostream>中的cin, cout更快。  
题目的输入会保证对特定结点从Random指针进行访问时，不会出现“死锁”，即输出的序列长度一定是有限的。  
输入和输出每一行中的各元素均用空格隔开。  
每删除或插入一个新的结点后，链表都需要进行更新！  
M不大于N。  

### [OJ-03] 排队照相问题  
#### [限制条件]  
时间限制: 1000 ms 内存限制: 2000 KB  
#### [问题描述]  
N（N为偶数）个高矮不同的人排成两排照相，要求每一排都是从矮到高排列，而第二排每个人比第一排对应的人要高，列出所有可能的结果。  
#### [输入格式]  
第一行正整数N（0<N<100）  
第二行第一个人的身高h1  
第三行第二个人的身高h2  
…  
第N+1行第N个人的身高hN  
#### [输出格式]  
1.每种情况占据一行；  
2.将第一排按照排队顺序输出身高，然后将第二排按照排队顺序输出身高；  
3.身高之间加空格（第二排最后一人后面为换行符，无空格），两排之间不加换行符（第一排最后一人与第二排第一人之间为空格）。  
4.最后统计所有情况数目并输出。  
#### [输入样例]  
4  
161  
162  
164  
163  
#### [输出样例]  
161 162 163 164  
161 163 162 164  
2  
或者下列输出也正确（即不同情况之间可交换顺序）：  
161 163 162 164  
161 162 163 164  
2  
#### [提示]
1.使用<stdio.h>中的scanf，printf。它们比<iostream>中的cin, cout更快。  
2.每种情况输出完成后要换行。  
3.在输出时，不同情况的输出先后顺序不影响答案的正确性。  

### [OJ-04] 鸿雁传书  
#### [限制条件]  
时间限制: 1000 ms 内存限制: 80000 KB  
#### [问题描述]  
随着科技的发展，通信的手段日新月异。然而不得不说，至今都没有比鸿雁传书更为深情浪漫的通信方式出现。  
两个迷恋地球文明&中华文化的【三体人】出于浪漫主义需求，决定以后通过鸿雁传书的方式来进行通信。为了方便起见，我们姑且叫他们大刘和大白。鸿雁传书，情真意切，大刘和大白的感情也一日比一日深厚。  
Fig.1 图文无关  
两人的私密通信，自然是“不足为外人道”的。为此大刘煞费苦心地设计了一套用01比特来表示每个三体文字的方式，称为“鸿雁传书字典”。其巧妙之处在于，任何一个01比特串都不会是其他串的前缀串。于是收到一大堆01比特的大白对照着“鸿雁传书字典”，就能原样知道大刘想写的是什么三体文字了。而别人手中没有这个字典，自然不知道这些比特的含义。一个非常简单的（只包含四个可选三体文字）例子Fig.2所示。   
Fig.2 合法的“鸿雁传书字典”及其传书过程示例  
好景不长，由于三体文字实在是博大精深，有成千上万个。原本的“鸿雁传书字典”是大刘随手设计的，每个三体字都要用好多好多比特来描述。大刘有一次问大白“你吃了没”竟然用了23333个比特，写了一大叠纸，鸿雁送到一半累得吐血掉进黑暗森林再没飞起来。  
Fig.3 累得掉进黑暗森林的鸿雁（注意这是三体的鸿雁，长得像鸽子是可以理解的）  
大白得知后伤心地哭了很久(●—●)，大刘也十分难过。他和大白保证会设计出新的、最好的“鸿雁传书字典”，为此他把自己和大白的所有传书都搜集了起来，并统计出了其中每一个三体文字的出现次数。  
做完这一切后，大刘对着这个统计表犯了难，该怎么设计出一个最好的“鸿雁传书字典”，使得平均意义上表示一个三体文字需要的比特数最少呢？你能帮帮大刘么？   
[注：文中图片来自互联网，侵权请联系17888833517撤回，谢谢~]  
#### [输入格式]  
输入共有 N+1 行。  
第 1 行包含一个整数N，代表大刘统计出的不同三体文字的数量。  
第 2 行到第 N+1 行每行有一个整数，代表大刘统计的所有书信里，这行对应的三体文字出现的总次数。  
 
##### [注意]  
 
1. 大刘为了请你帮忙，已经把所有三体字按照【1体】-【2体】-【3体】- …… -【N体】的顺序进行了排列，也即第 k 行代表 “【k-1体】” 这个字出现的总次数。  
2. N不超过300,000。  

#### [输出格式]  
输出共有 N+1 行。  
第 1 行包含一个浮点数F，代表你设计的最优“鸿雁传书字典”中，表示每个三体字需要的平均比特数。保留6位小数。  
第 2 行到第 N+1 行每行有一个“01”比特串，代表你设计的最优“鸿雁传书字典”中，表示这行对应三体字的01比特编码。  

##### [注意]  
1. 输出“鸿雁传书字典”中编码方案的时候，必须也按照【1体】-【2体】-【3体】- …… -【N体】的顺序进行输出，也即和输入文件中的顺序匹配。   
2. 表示“鸿雁传书字典”中的编码方案必须使用“0”和“1”来表示，例如“0101”。不接受别的等价描述，例如“2323”。  
3. 严格保证输出是N+1行，并且每行中不能有和编码比特无关的空格或其他字符。  

#### [输入样例]  
5  
2  
1  
2  
2  
3  
#### [输出样例]  
2.300000  
111  
110  
01  
00  
10  
#### [提示]   
1. 显然最优编码方案是不唯一的，大家只需要提供随意一种最优编码方案即可。  
2. 请大家务必看清输出格式的所有要求。  
3. 如果用到排序算法，请查资料学习编写快速排序的代码（冒泡排序可能无法过所有数据）。  

### [OJ-05]图算法：推荐潜在好友  
#### [限制条件]  
时间限制: 2000 ms 内存限制: 6000 KB  
#### [问题描述]  
社交网络可以用一个图来描述。假定有N个使用者，每个使用者可以用一个节点表示，如果使用者m和使用者n已经是线上朋友，表示两个节点已经连接，即图中包含连接m和n的边。在这个练习中，我们将为使用者推荐可能的朋友。  
给定表示一个社交网络的图，包含N个节点和M条边。如果节点m和n不直接相连，但与K个以上（包括K个）的相同节点连接，我们可以认为他们可能认识，请给出指定用户的潜在好友（暂时还未直接连接的节点）。对于给定用户，请将其所有潜在好友按照他们共同好友数量由多到少排列输出，对于共同好友数量相同的情况，请按照序号从小到大排列输出。  
#### [输入格式]  
输入的第一行是三个整数N，K，U。其中N表示社交网络中用户的个数，即网络节点的个数。K表示共同好友数不少于K的两个用户才互相算作潜在好友。U表示需要输出标号为U的用户的潜在好友，对应矩阵行/列标号为U的节点，U从0开始计。  
输入的第二行到第N+1行是用户之间的图的邻接矩阵：0代表不是好友，1代表是好友。  
#### [输出格式]  
请在一行中，输出用户U所有可能认识的人（共同好友数量不少于K并且目前还不是好友的人）的编号（即对应的矩阵的行列序号，从0开始计数），序号之间用空格隔开。按照共同好友数量由多到少排列输出，对于共同好友数量相同的潜在朋友，请按照序号从小到大排列输出。  
#### [输入样例]  
6 1 3  
0 1 0 1 0 1   
1 0 0 0 0 1   
0 0 0 0 0 1   
1 0 0 0 0 1   
0 0 0 0 0 1   
1 1 1 1 1 0  
#### [输出样例]  
1 2 4  
#### [提示]  
图的邻接矩阵对角线元素没有意义，且为对称阵。  

### [OJ-06]杨氏矩阵
#### [限制条件]  
时间限制: 4000 ms 内存限制: 20000 KB  
#### [问题描述]  
杨氏矩阵（Young Tableau）是对组合表示理论和舒伯特演算很有用的工具，它提供了一种方便的方式来描述对称和一般线性群的群表示，并研究它们的性质。本次任务中我们将对杨氏矩阵的基本操作进行一些探索。  
杨氏矩阵一般指一个m×n 的二维数组，它的每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。需要注意的是，在这个矩阵中允许一些元素不存在的情况发生，也可以认为这些元素被设置成为无穷大(∞)。  
可以容易发现，对于一组特定数据，杨氏矩阵的形式并不唯一。  
在本次实验中我们需要完成杨氏矩阵的创建、查找、增加、删除操作。  
#### [输入格式]  
输入一共有五行  
第一行包含四个正整数，分别为N N1 N2 N3  
第二行包含N个整数，储存了杨氏矩阵的内容，矩阵元素均为大于零不重复的正整数，-1代表矩阵内部换行，且该行最后一个数为-1，注意N并不等于矩阵元素的个数  
第三行包含N1个正整数，需要同学们查找这些元素在杨氏矩阵中的位置  
第四行包含N2个正整数，每一个代表需要插入到当前杨氏矩阵中的元素，不会给出重复的元素。  
第五行包含N3个正整数，每一个代表需要删除的元素，不会给出当前矩阵中不存在的元素。  
#### [输入数据范围]  
矩阵中元素的值的值位于区间[1,2147483647]内。  
0<N<1000000,0<N1<N , 0<N2<50000 , 0<N3<50000  
#### [输出格式]  
输出包含三行。  
第一行给出查找结果：依次给出各个元素的坐标，如果元素不存在则认为坐标是(-1,-1)  
第二行给出插入操作完成后的杨氏矩阵：分别输出每一行的所有元素值，输出-1代表换行，最后一个输出必须是-1。结果不唯一，你需要保证：1、结果是一个杨氏矩阵。2、矩阵中包含当前存在的所有元素  
第三行给出删除操作完成后的杨氏矩阵：分别输出每一行的所有元素值，输出-1代表换行，最后一个输出必须是-1。结果不唯一，你需要保证：1、结果是一个杨氏矩阵。2、矩阵中包含剩余的所有元素  
#### [输入样例]  
11 2 2 2  
2 5 6 -1 4 10 -1 7 -1 15 -1  
5 13  
8 12  
10 7  
#### [输出样例]  
0 1 -1 -1  
2 5 6 8 -1 4 10 12 -1 7 -1 15 -1  
2 5 6 8 -1 4 12 -1 15 -1  
#### [提示]  
输入和输出每一行中的各元素均用空格隔开  
每插入或者删除一个元素后，后续操作均在新生成的矩阵上进行。  
注：本实验中增加、删除后的矩阵结果有多种可能，只要同学们输出一个元素值符合要求的杨氏矩阵即可  
